<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>DingCAD - Web Viewer</title>
    <!-- Monaco Editor for code editing -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js" 
            onerror="window.monacoLoadFailed = true; console.warn('Monaco Editor failed to load, will use fallback editor');"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }
        
        #canvas-container {
            flex: 1 1 0%;
            position: relative;
            background: #0f0f0f;
            width: 100%;
            min-width: 0;
            min-height: 0;
            margin: 0;
            padding: 0;
            border: none;
            box-sizing: border-box;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            padding: 0;
            border: none;
            outline: none;
        }
        
        #toolbar {
            background: #2a2a2a;
            padding: 10px 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-top: 1px solid #3a3a3a;
            flex-shrink: 0;
        }
        
        #toolbar-buttons {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 15px;
        }
        
        #code-editor-panel {
            background: #1e1e1e;
            border-top: 1px solid #3a3a3a;
            display: flex !important;
            flex-direction: column;
            transition: height 0.3s ease;
            min-height: 40px;
            height: 40px;
            overflow: hidden;
            margin-left: -20px;
            margin-right: -20px;
            margin-bottom: -10px;
            width: calc(100% + 40px);
        }
        
        #code-editor-panel.expanded {
            height: 400px;
            max-height: 50vh;
        }
        
        #code-editor-panel.minimized {
            height: 40px;
            min-height: 40px;
        }
        
        @media (max-width: 768px) {
            #code-editor-panel {
                height: 35px;
            }
            
            #code-editor-panel.expanded {
                height: 300px;
                max-height: 40vh;
            }
        }
        
        #code-editor-panel.hidden {
            display: none !important;
        }
        
        #editor-header {
            background: #2a2a2a;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            min-height: 40px;
            flex-shrink: 0;
        }
        
        #code-editor-panel.expanded #editor-header {
            border-bottom: 1px solid #3a3a3a;
        }
        
        #editor-header:hover {
            background: #333;
        }
        
        @media (max-width: 768px) {
            #editor-header {
                padding: 6px 12px;
                min-height: 35px;
            }
        }
        
        #editor-header h3 {
            margin: 0;
            font-size: 14px;
            color: #e0e0e0;
            flex: 1;
        }
        
        @media (max-width: 768px) {
            #editor-header h3 {
                font-size: 12px;
            }
        }
        
        #editor-close {
            background: transparent;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 18px;
            padding: 0 10px;
            transition: transform 0.2s ease;
        }
        
        #editor-close:hover {
            color: #fff;
        }
        
        #code-editor-panel.minimized #editor-close {
            transform: rotate(180deg);
        }
        
        #editor-content {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: none;
        }
        
        #code-editor-panel.expanded #editor-content {
            display: block;
        }
        
        
        #library-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 300px;
            height: 100vh;
            background: #1e1e1e;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            z-index: 999;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3);
        }
        
        #library-panel.visible {
            transform: translateX(0);
        }
        
        #library-header {
            background: #2a2a2a;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #3a3a3a;
        }
        
        #library-header h3 {
            margin: 0;
            font-size: 16px;
            color: #e0e0e0;
        }
        
        #library-close {
            background: transparent;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 18px;
            padding: 0 10px;
        }
        
        #library-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .library-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .library-item:hover {
            background: #3a3a3a;
        }
        
        .library-item.selected {
            background: #1a3a2a;
            border-color: #2a5a3a;
        }
        
        .library-item.selected:hover {
            background: #2a4a3a;
        }
        
        .library-item-name {
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 4px;
        }
        
        .library-item-desc {
            font-size: 12px;
            color: #a0a0a0;
            margin-bottom: 4px;
        }
        
        .library-item-dims {
            font-size: 11px;
            color: #888;
            font-family: 'Courier New', monospace;
            margin-top: 2px;
        }
        
        .library-folder-header {
            padding: 8px 12px;
            margin-top: 12px;
            margin-bottom: 4px;
            font-size: 12px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .library-folder-header:first-child {
            margin-top: 0;
        }
        
        #library-toggle {
            font-size: 14px;
            padding: 8px 16px;
        }
        
        #editor {
            flex: 1;
            width: 100%;
            height: 100%;
        }
        
        #editor-fallback {
            flex: 1;
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: #e0e0e0;
            border: none;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: none;
            outline: none;
        }
        
        button {
            background: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #5a5a5a;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #5a5a5a;
        }
        
        button:active {
            background: #3a3a3a;
        }
        
        button.primary {
            background: #0066cc;
            border-color: #0077dd;
        }
        
        button.primary:hover {
            background: #0077dd;
        }
        
        #status {
            flex: 1;
            padding: 8px 15px;
            background: #2a2a2a;
            border-radius: 4px;
            font-size: 13px;
            color: #a0a0a0;
        }
        
        #status.error {
            color: #ff6b6b;
        }
        
        #status.success {
            color: #51cf66;
        }
        
        #unsaved-warning {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #ff6b6b;
            color: #fff;
            padding: 12px 20px;
            display: none;
            align-items: center;
            justify-content: space-between;
            z-index: 10000;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
            font-size: 14px;
        }
        
        #unsaved-warning.visible {
            display: flex;
        }
        
        #unsaved-warning-message {
            flex: 1;
        }
        
        #unsaved-warning-actions {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        #unsaved-warning button {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 6px 12px;
            font-size: 13px;
        }
        
        #unsaved-warning button:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        #unsaved-warning button.copy-btn {
            background: rgba(255, 255, 255, 0.25);
        }
        
        #unsaved-warning button.copy-btn:hover {
            background: rgba(255, 255, 255, 0.35);
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #888;
        }
        
        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #0066cc;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        
        #version-history-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 350px;
            height: 100vh;
            background: #1e1e1e;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            z-index: 998;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
        }
        
        #version-history-panel.visible {
            transform: translateX(0);
        }
        
        #version-history-header {
            background: #2a2a2a;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #3a3a3a;
        }
        
        #version-history-header h3 {
            margin: 0;
            font-size: 16px;
            color: #e0e0e0;
        }
        
        #version-history-close {
            background: transparent;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 18px;
            padding: 0 10px;
        }
        
        #version-history-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .version-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .version-item:hover {
            background: #3a3a3a;
        }
        
        .version-item.current {
            border-color: #0066cc;
            background: #2a3a4a;
        }
        
        .version-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .version-item-time {
            font-size: 12px;
            color: #888;
        }
        
        .version-item-preview {
            font-size: 11px;
            color: #a0a0a0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-height: 40px;
            margin-top: 4px;
        }
        
        .version-item-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        
        .version-item-actions button {
            padding: 4px 12px;
            font-size: 12px;
        }
        
        #version-history-toggle {
            font-size: 14px;
            padding: 8px 16px;
        }
    </style>
</head>
<body>
        <div id="unsaved-warning">
            <div id="unsaved-warning-message">
                ‚ö†Ô∏è You have unsaved changes. If you refresh the page, your changes will be lost. Copy your code to clipboard to save it.
            </div>
            <div id="unsaved-warning-actions">
                <button id="copy-code-btn" class="copy-btn" onclick="copyCodeToClipboard()">Copy Code</button>
            </div>
        </div>
        
        <div id="container">
        <div id="version-history-panel">
            <div id="version-history-header">
                <h3>Version History</h3>
                <button id="version-history-close">√ó</button>
            </div>
            <div id="version-history-list"></div>
        </div>
        
        <div id="library-panel">
            <div id="library-header">
                <h3>Library</h3>
                <button id="library-close">√ó</button>
            </div>
            <div id="library-list"></div>
        </div>
        
        <div id="canvas-container">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>Loading DingCAD...</div>
            </div>
            <canvas id="canvas"></canvas>
        </div>
        
        <div id="toolbar">
            <div id="toolbar-buttons">
                <button id="edit-btn">Edit Code</button>
                <button id="reset-btn">Reset View</button>
                <div id="status">Ready</div>
                <button id="library-toggle" title="Library">Library</button>
            </div>
            <div id="code-editor-panel" class="minimized" style="display: flex;">
                <div id="editor-header">
                    <h3 id="editor-title">Code Editor</h3>
                    <button id="editor-close" title="Toggle expand/minimize">‚ñº</button>
                </div>
                <div id="editor-content">
                    <div id="editor"></div>
                    <textarea id="editor-fallback" style="display: none;"></textarea>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        // Module loader and initialization
        let Module = null;
        let isInitialized = false;
        
        // Initialize Emscripten module
        async function initModule() {
            try {
                // Log build version for tracking updates
                const buildTimestamp = new Date().toISOString();
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                console.log('üöÄ DingCAD Web Viewer');
                console.log(`üì¶ Build: ${buildTimestamp}`);
                console.log(`üîÑ Refresh: ${window.location.href}?t=${Date.now()}`);
                console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
                
                // Get canvas element before module creation (needed for GLFW initialization)
                const canvas = document.getElementById('canvas');
                
                // Load the WebAssembly module
                // With EXPORT_ES6=1 and EXPORT_NAME='createDingCADModule', the module exports:
                // - default export: the factory function (preferred)
                // - named export 'createDingCADModule': the factory function (fallback)
                const moduleFactory = await import('./dingcad_viewer.js');
                const createModule = moduleFactory.default || moduleFactory.createDingCADModule;
                if (typeof createModule !== 'function') {
                    const availableExports = Object.keys(moduleFactory).join(', ') || 'none';
                    throw new Error(
                        `Module factory function not found. ` +
                        `Expected default or createDingCADModule export. ` +
                        `Available exports: ${availableExports}`
                    );
                }
                
                // Track if main has been called to prevent double initialization
                let mainCalled = false;
                
                // Create module with configuration (canvas must be set before GLFW init)
                Module = await createModule({
                    canvas: canvas,
                    onRuntimeInitialized: function() {
                        // Runtime is ready, now call main (only once)
                        if (mainCalled) {
                            console.log('Main already called, skipping');
                            return;
                        }
                        
                        // 'this' refers to the module instance in Emscripten callbacks
                        const moduleInst = this || Module;
                        
                        // Main runs automatically with INVOKE_RUN=1
                        // Just hide loading and mark as initialized
                        mainCalled = true;
                        document.getElementById('loading').style.display = 'none';
                        isInitialized = true;
                        
                        // Log successful initialization
                        console.log('‚úÖ DingCAD initialized successfully');
                        console.log(`üìÖ Initialized at: ${new Date().toISOString()}`);
                        
                        updateStatus('Ready', 'success');
                        
                        // Set up canvas resize handler
                        setupCanvasResize();
                        
                        // Force immediate resize after module is ready
                        setTimeout(() => {
                            resizeCanvas();
                        }, 100);
                        
                        // Check if we should auto-load the last library item
                        moduleInitialized = true;
                        checkAndAutoLoad();
                    },
                    print: function(text) {
                        console.log(text);
                    },
                    printErr: function(text) {
                        console.error(text);
                    }
                });
                
                // If runtime already initialized (synchronous case), call main immediately
                // But only if onRuntimeInitialized hasn't been called yet
                if (Module && Module.ready && !mainCalled) {
                    try {
                        let callMainFn = null;
                        if (typeof Module.callMain === 'function') {
                            callMainFn = () => Module.callMain();
                        } else if (typeof Module._main === 'function') {
                            callMainFn = () => Module._main();
                        }
                        
                        if (callMainFn) {
                            mainCalled = true;
                            callMainFn();
                    document.getElementById('loading').style.display = 'none';
                    isInitialized = true;
                    updateStatus('Ready', 'success');
                    // Set up canvas resize handler
                    setupCanvasResize();
                    // Force immediate resize after module is ready
                    setTimeout(() => {
                        resizeCanvas();
                    }, 100);
                        } else {
                            console.warn('callMain not available synchronously, waiting for onRuntimeInitialized');
                        }
                    } catch (err) {
                        console.error('Error calling main (sync):', err);
                        updateStatus('Error: ' + err.message, 'error');
                        mainCalled = false; // Allow retry
                    }
                }
            } catch (error) {
                console.error('‚ùå Failed to initialize:', error);
                console.error(`üìÖ Error at: ${new Date().toISOString()}`);
                updateStatus('Failed to load: ' + error.message, 'error');
            }
        }
        
        function updateStatus(message, type = '') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = type;
        }
        
        // Canvas resize handler - ensures canvas internal resolution matches display size
        function resizeCanvas() {
            const canvas = document.getElementById('canvas');
            const container = document.getElementById('canvas-container');
            if (!canvas || !container) return;
            
            // Get the actual pixel dimensions of the container
            const rect = container.getBoundingClientRect();
            const width = Math.floor(rect.width);
            const height = Math.floor(rect.height);
            
            // Only resize if dimensions actually changed
            if (canvas.width !== width || canvas.height !== height) {
                // Update canvas internal resolution to match display size
                canvas.width = width;
                canvas.height = height;
                
                // Ensure canvas is positioned at top-left of container
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                
                // Canvas resize is handled automatically by Emscripten/raylib
                // The canvas width/height attributes are sufficient for proper rendering
                // Emscripten will automatically update GetScreenWidth/GetScreenHeight
                
                console.log(`üñºÔ∏è Canvas resized to ${width}x${height}`);
            }
        }
        
        // Set up resize observer and window resize listener
        let canvasResizeSetup = false;
        let resizeTimeout = null;
        let editorPanelTransitioning = false; // Flag to prevent resize during editor panel transitions
        
        function setupCanvasResize() {
            if (canvasResizeSetup) return; // Already set up
            const container = document.getElementById('canvas-container');
            if (!container) return;
            
            // Initial resize
            resizeCanvas();
            
            // Use ResizeObserver for better performance and accuracy
            // Debounce resize events to prevent excessive calls during panel animations
            const resizeObserver = new ResizeObserver(() => {
                // Don't resize during editor panel transitions
                if (editorPanelTransitioning) {
                    return;
                }
                
                // Clear any pending resize
                if (resizeTimeout) {
                    clearTimeout(resizeTimeout);
                }
                // Debounce resize to avoid triggering during panel animations
                // Use longer debounce to cover editor panel animation (300ms)
                resizeTimeout = setTimeout(() => {
                    // Double-check we're not in a transition
                    if (!editorPanelTransitioning) {
                        resizeCanvas();
                    }
                    resizeTimeout = null;
                }, 400); // 400ms debounce (longer than 300ms transition)
            });
            resizeObserver.observe(container);
            
            // Fallback to window resize for older browsers
            window.addEventListener('resize', () => {
                // Don't resize during editor panel transitions
                if (editorPanelTransitioning) {
                    return;
                }
                
                // Clear any pending resize
                if (resizeTimeout) {
                    clearTimeout(resizeTimeout);
                }
                // Debounce resize
                resizeTimeout = setTimeout(() => {
                    if (!editorPanelTransitioning) {
                        resizeCanvas();
                    }
                    resizeTimeout = null;
                }, 400);
            });
            
            canvasResizeSetup = true;
            console.log('‚úÖ Canvas resize handler initialized');
        }
        
        // Monaco Editor setup with fallback
        let editor = null;
        let useFallbackEditor = false;
        let codeEditorVisible = false; // Start minimized
        let currentFileName = null;
        let saveTimeout = null;
        let originalCode = null; // Track original code from library
        let hasUnsavedChanges = false; // Track if user has modified code
        let isUserEditing = false; // Track if user is actively editing (not programmatic changes)
        
        // Version History System
        const VERSION_HISTORY_KEY = 'dingcad_version_history';
        const MAX_VERSIONS = 50; // Maximum number of versions to keep
        let versionHistory = [];
        let currentVersionId = null;
        let versionHistoryPanelVisible = false;
        let isRestoringVersion = false;
        
        // Load version history from localStorage
        function loadVersionHistory() {
            try {
                const stored = localStorage.getItem(VERSION_HISTORY_KEY);
                if (stored) {
                    versionHistory = JSON.parse(stored);
                    console.log(`üìú Loaded ${versionHistory.length} versions from history`);
                } else {
                    versionHistory = [];
                }
            } catch (e) {
                console.warn('‚ö†Ô∏è Failed to load version history:', e);
                versionHistory = [];
            }
        }
        
        // Save version history to localStorage
        function saveVersionHistory() {
            try {
                localStorage.setItem(VERSION_HISTORY_KEY, JSON.stringify(versionHistory));
            } catch (e) {
                console.warn('‚ö†Ô∏è Failed to save version history:', e);
                // If storage is full, try to remove old versions
                if (e.name === 'QuotaExceededError') {
                    // Keep only the most recent 25 versions
                    versionHistory = versionHistory.slice(-25);
                    try {
                        localStorage.setItem(VERSION_HISTORY_KEY, JSON.stringify(versionHistory));
                    } catch (e2) {
                        console.error('‚ùå Still failed to save after cleanup:', e2);
                    }
                }
            }
        }
        
        // Save a new version to history
        function saveVersion(code, filename) {
            if (isRestoringVersion) {
                return; // Don't save when restoring
            }
            
            const now = new Date();
            const version = {
                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                timestamp: now.getTime(),
                date: now.toISOString(),
                code: code,
                filename: filename || currentFileName || 'Untitled',
                preview: code.substring(0, 100).replace(/\n/g, ' ').trim()
            };
            
            // Check if this is the same as the last version (avoid duplicates)
            if (versionHistory.length > 0) {
                const lastVersion = versionHistory[versionHistory.length - 1];
                if (lastVersion.code === code && lastVersion.filename === version.filename) {
                    // Same code, just update the current version ID
                    currentVersionId = lastVersion.id;
                    return;
                }
            }
            
            versionHistory.push(version);
            currentVersionId = version.id;
            
            // Limit history size
            if (versionHistory.length > MAX_VERSIONS) {
                versionHistory = versionHistory.slice(-MAX_VERSIONS);
            }
            
            saveVersionHistory();
            updateVersionHistoryUI();
            console.log(`üíæ Saved version: ${version.filename} (${new Date(version.timestamp).toLocaleTimeString()})`);
        }
        
        // Revert to a specific version
        function revertToVersion(versionId) {
            const version = versionHistory.find(v => v.id === versionId);
            if (!version) {
                console.error('‚ùå Version not found:', versionId);
                return;
            }
            
            console.log(`‚Ü©Ô∏è Reverting to version: ${version.filename} (${new Date(version.timestamp).toLocaleString()})`);
            
            isRestoringVersion = true;
            if (editor) {
                setEditorCode(version.code, false); // Don't update original code when restoring version
                if (!useFallbackEditor) {
                    // Force Monaco to update
                    setTimeout(() => {
                        editor.layout();
                        const model = editor.getModel();
                        if (model) {
                            editor.setPosition({ lineNumber: 1, column: 1 });
                        }
                        editor.render(true);
                    }, 50);
                }
            }
            
            // Update filename if it changed
            if (version.filename !== currentFileName) {
                updateEditorTitle(version.filename);
            }
            
            currentVersionId = versionId;
            updateVersionHistoryUI();
            
            // Execute the code after a short delay
            setTimeout(() => {
                isRestoringVersion = false;
                executeCode();
            }, 100);
        }
        
        // Update the version history UI
        function updateVersionHistoryUI() {
            const list = document.getElementById('version-history-list');
            if (!list) return;
            
            list.innerHTML = '';
            
            if (versionHistory.length === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No version history yet</div>';
                return;
            }
            
            // Show versions in reverse chronological order (newest first)
            const sortedVersions = [...versionHistory].reverse();
            
            sortedVersions.forEach(version => {
                const item = document.createElement('div');
                item.className = 'version-item' + (version.id === currentVersionId ? ' current' : '');
                
                const date = new Date(version.timestamp);
                const timeStr = date.toLocaleString();
                const relativeTime = getRelativeTime(date);
                
                item.innerHTML = `
                    <div class="version-item-header">
                        <strong style="color: #e0e0e0;">${version.filename}</strong>
                        <span class="version-item-time">${relativeTime}</span>
                    </div>
                    <div class="version-item-preview">${escapeHtml(version.preview)}${version.code.length > 100 ? '...' : ''}</div>
                    <div class="version-item-actions">
                        <button class="primary" onclick="window.revertToVersion('${version.id}')">Revert</button>
                        <button onclick="window.viewVersion('${version.id}')">View</button>
                    </div>
                `;
                
                list.appendChild(item);
            });
        }
        
        // Helper function to get relative time
        function getRelativeTime(date) {
            const now = new Date();
            const diffMs = now.getTime() - date.getTime();
            const diffSecs = Math.floor(diffMs / 1000);
            const diffMins = Math.floor(diffSecs / 60);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);
            
            if (diffSecs < 60) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Make functions available globally for onclick handlers
        window.revertToVersion = revertToVersion;
        window.viewVersion = function(versionId) {
            const version = versionHistory.find(v => v.id === versionId);
            if (!version) return;
            
            // Show version in a modal or alert (simple version)
            const codePreview = version.code.substring(0, 500) + (version.code.length > 500 ? '\n...' : '');
            alert(`Version from ${new Date(version.timestamp).toLocaleString()}\n\n${codePreview}`);
        };
        
        // Toggle version history panel
        function toggleVersionHistoryPanel() {
            versionHistoryPanelVisible = !versionHistoryPanelVisible;
            const panel = document.getElementById('version-history-panel');
            if (versionHistoryPanelVisible) {
                panel.classList.add('visible');
                updateVersionHistoryUI();
            } else {
                panel.classList.remove('visible');
            }
        }
        
        // Initialize fallback editor (textarea)
        function initFallbackEditor() {
            console.log('Using fallback textarea editor');
            useFallbackEditor = true;
            const fallbackEditor = document.getElementById('editor-fallback');
            const monacoEditor = document.getElementById('editor');
            fallbackEditor.style.display = 'block';
            monacoEditor.style.display = 'none';
            fallbackEditor.value = '// Code editor - load a library item or write your own scene\n// Example:\n// export const scene = cube({ size: [1, 1, 1], center: true });';
            
            // Set initial title
            updateEditorTitle(null);
            
            // Auto-save and execute on change (with debounce)
            fallbackEditor.addEventListener('input', () => {
                // Track changes if user is editing
                if (isUserEditing) {
                    const currentCode = fallbackEditor.value;
                    // Check if code has changed from original
                    if (originalCode !== null && currentCode !== originalCode) {
                        hasUnsavedChanges = true;
                        showUnsavedWarning();
                    } else if (currentCode === originalCode) {
                        hasUnsavedChanges = false;
                        hideUnsavedWarning();
                    }
                }
                
                if (saveTimeout) clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    const code = fallbackEditor.value;
                    // Only save version and execute if module is ready
                    if (Module && isInitialized && editor) {
                        saveVersion(code, currentFileName);
                        executeCode();
                    }
                }, 1000); // 1 second debounce
            });
            
            editor = {
                getValue: () => fallbackEditor.value,
                setValue: (value) => { fallbackEditor.value = value; },
                layout: () => {} // No-op for fallback
            };
        }
        
        // Initialize editor (Monaco or fallback)
        function initEditor() {
            // Check if Monaco failed to load or if require is not available
            if (window.monacoLoadFailed || typeof require === 'undefined') {
                initFallbackEditor();
            } else {
                // Try to initialize Monaco Editor
                try {
                    require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } });
                    require(['vs/editor/editor.main'], function () {
                        editor = monaco.editor.create(document.getElementById('editor'), {
                            value: '// Code editor - load a library item or write your own scene\n// Example:\n// export const scene = cube({ size: [1, 1, 1], center: true });',
                            language: 'javascript',
                            theme: 'vs-dark',
                            fontSize: 14,
                            minimap: { enabled: false },
                            scrollBeyondLastLine: false,
                            automaticLayout: true,
                            wordWrap: 'on'
                        });
                        
                        // Set initial title when editor loads with default code
                        updateEditorTitle(null);
                        
                        // Auto-save and execute on change (with debounce)
                        editor.onDidChangeModelContent(() => {
                            // Only track changes if user is editing (not programmatic)
                            if (isUserEditing) {
                                const currentCode = editor.getValue();
                                // Check if code has changed from original
                                if (originalCode !== null && currentCode !== originalCode) {
                                    hasUnsavedChanges = true;
                                    showUnsavedWarning();
                                } else if (currentCode === originalCode) {
                                    hasUnsavedChanges = false;
                                    hideUnsavedWarning();
                                }
                            }
                            
                            if (saveTimeout) clearTimeout(saveTimeout);
                            saveTimeout = setTimeout(() => {
                                const code = editor.getValue();
                                // Only save version and execute if module is ready
                                if (Module && isInitialized) {
                                    saveVersion(code, currentFileName);
                                    executeCode();
                                }
                            }, 1000); // 1 second debounce
                        });
                    }, function(error) {
                        console.error('Failed to load Monaco Editor:', error);
                        initFallbackEditor();
                    });
                } catch (error) {
                    console.error('Failed to initialize Monaco Editor:', error);
                    initFallbackEditor();
                }
            }
        }
        
        // Initialize editor after a short delay to allow Monaco loader to fail if needed
        setTimeout(initEditor, 100);
        
        // Code editor panel toggle (minimize/expand)
        function toggleCodeEditorPanel() {
            const panel = document.getElementById('code-editor-panel');
            
            // Set flag to prevent canvas resize during transition
            editorPanelTransitioning = true;
            
            if (panel.classList.contains('minimized')) {
                // Expand
                panel.classList.remove('minimized');
                panel.classList.add('expanded');
                if (editor && !useFallbackEditor) {
                    // Force Monaco to re-render and re-tokenize when expanded
                    setTimeout(() => {
                        editor.layout();
                        const model = editor.getModel();
                        if (model) {
                            // Force re-tokenization by resetting language
                            monaco.editor.setModelLanguage(model, 'javascript');
                            // Scroll through document to trigger tokenization
                            const lineCount = model.getLineCount();
                            if (lineCount > 0) {
                                editor.revealLine(lineCount);
                                setTimeout(() => {
                                    editor.revealLine(1);
                                    editor.render(true);
                                    editor.focus();
                                }, 50);
                            } else {
                                editor.render(true);
                                editor.focus();
                            }
                        }
                    }, 150);
                }
            } else {
                // Minimize
                panel.classList.remove('expanded');
                panel.classList.add('minimized');
            }
            
            // Clear the flag after the transition completes (300ms + buffer)
            setTimeout(() => {
                editorPanelTransitioning = false;
            }, 350); // 350ms to cover 300ms transition + buffer
        }
        
        document.getElementById('editor-close').addEventListener('click', (e) => {
            e.stopPropagation();
            toggleCodeEditorPanel();
        });
        
        // Also allow clicking header to toggle
        document.getElementById('editor-header').addEventListener('click', () => {
            toggleCodeEditorPanel();
        });
        
        // Function to update editor title with filename
        function updateEditorTitle(filename) {
            const titleElement = document.getElementById('editor-title');
            if (filename) {
                titleElement.textContent = filename;
                currentFileName = filename;
            } else {
                titleElement.textContent = 'Code Editor';
                currentFileName = null;
            }
        }
        
        // Helper function to set editor code with proper syntax highlighting
        function setEditorCode(code, isUserAction = false) {
            if (!editor) return;
            
            // If this is a user action (like loading library), update original code
            // If this is programmatic (like restoring version), don't update original
            if (isUserAction) {
                originalCode = code;
                hasUnsavedChanges = false;
                hideUnsavedWarning();
            }
            
            // Mark as not user editing during programmatic changes
            isUserEditing = false;
            
            if (useFallbackEditor) {
                // Fallback editor - just set value
                editor.setValue(code);
            } else {
                // Monaco Editor - ensure proper tokenization
                const model = editor.getModel();
                if (model) {
                    // Check if editor panel is visible
                    const panel = document.getElementById('code-editor-panel');
                    const isExpanded = panel.classList.contains('expanded');
                    
                    // Set the code - this triggers Monaco's change detection
                    editor.setValue(code);
                    
                    // Force Monaco to re-tokenize by resetting the language
                    // This ensures the entire document is properly tokenized
                    monaco.editor.setModelLanguage(model, 'javascript');
                    
                    // Use a multi-step approach to ensure all lines are tokenized
                    setTimeout(() => {
                        // Step 1: Layout and initial render
                        editor.layout();
                        editor.render(true);
                        
                        // Step 2: Force tokenization by scrolling through the document
                        // This ensures all lines are tokenized, even if not visible
                        if (model.getLineCount() > 0) {
                            // Scroll to end and back to trigger tokenization of all lines
                            const lineCount = model.getLineCount();
                            editor.revealLine(lineCount);
                            setTimeout(() => {
                                editor.revealLine(1);
                                editor.render(true);
                                
                                // Step 3: Final render after tokenization
                                setTimeout(() => {
                                    editor.layout();
                                    editor.render(true);
                                    
                                    // If expanded, ensure focus for proper rendering
                                    if (isExpanded) {
                                        editor.focus();
                                    }
                                }, 50);
                            }, 50);
                        } else {
                            editor.render(true);
                            if (isExpanded) {
                                editor.focus();
                            }
                        }
                    }, 100);
                } else {
                    // Fallback if model doesn't exist
                    editor.setValue(code);
                    setTimeout(() => {
                        editor.layout();
                        editor.render(true);
                    }, 50);
                }
            }
            
            // Re-enable user editing tracking after a short delay
            setTimeout(() => {
                isUserEditing = true;
            }, 200);
        }
        
        // Show unsaved changes warning
        function showUnsavedWarning() {
            const warning = document.getElementById('unsaved-warning');
            if (warning) {
                warning.classList.add('visible');
            }
        }
        
        // Hide unsaved changes warning
        function hideUnsavedWarning() {
            const warning = document.getElementById('unsaved-warning');
            if (warning) {
                warning.classList.remove('visible');
            }
        }
        
        // Copy code to clipboard
        function copyCodeToClipboard() {
            if (!editor) return;
            
            const code = editor.getValue();
            navigator.clipboard.writeText(code).then(() => {
                const copyBtn = document.getElementById('copy-code-btn');
                if (copyBtn) {
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = 'Copied!';
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy code:', err);
                // Fallback for older browsers
                const textarea = document.createElement('textarea');
                textarea.value = code;
                document.body.appendChild(textarea);
                textarea.select();
                try {
                    document.execCommand('copy');
                    const copyBtn = document.getElementById('copy-code-btn');
                    if (copyBtn) {
                        const originalText = copyBtn.textContent;
                        copyBtn.textContent = 'Copied!';
                        setTimeout(() => {
                            copyBtn.textContent = originalText;
                        }, 2000);
                    }
                } catch (e) {
                    alert('Failed to copy code. Please copy manually.');
                }
                document.body.removeChild(textarea);
            });
        }
        
        // Make copyCodeToClipboard globally accessible for onclick handler
        window.copyCodeToClipboard = copyCodeToClipboard;
        
        function executeCode() {
            if (!Module || !editor || !isInitialized) {
                console.warn('‚ö†Ô∏è Cannot execute code: Module or editor not ready');
                return;
            }
            
            const code = editor.getValue();
            if (!code || code.trim().length === 0) {
                console.warn('‚ö†Ô∏è Cannot execute: empty code');
                return;
            }
            
            // Check if code is only comments (common pattern for placeholder code)
            const codeWithoutComments = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
            if (codeWithoutComments.length === 0) {
                console.warn('‚ö†Ô∏è Cannot execute: code contains only comments');
                return;
            }
            
            // Check if code exports a scene
            if (!code.includes('export') && !code.includes('export const scene') && !code.includes('export { scene }')) {
                console.warn('‚ö†Ô∏è Code does not appear to export a scene');
                // Don't return - let it try anyway, might be a function that will be wrapped
            }
            
            try {
                console.log('üìù Executing code...');
                console.log('Code preview:', code.substring(0, 200) + (code.length > 200 ? '...' : ''));
                // Write code to virtual filesystem and load it
                Module.FS.writeFile('/tmp/scene.js', code);
                // Call the C++ function to load the scene
                Module.ccall('loadSceneFromCode', null, ['string'], [code]);
                console.log('‚úÖ Code execution call completed');
                
                // Poll for status updates with detailed error reporting
                let attempts = 0;
                const maxAttempts = 50; // 5 seconds max wait
                const checkStatus = () => {
                    attempts++;
                    try {
                        const statusMsg = Module.ccall('getStatusMessage', 'string', [], []);
                        console.log(`üìä Status check ${attempts}:`, statusMsg);
                        
                        if (statusMsg && statusMsg.includes('Error')) {
                            console.error('‚ùå Scene load failed with error:', statusMsg);
                            updateStatus(statusMsg, 'error');
                            return;
                        }
                        
                        if (statusMsg && statusMsg.includes('successfully')) {
                            console.log('‚úÖ Scene loaded successfully:', statusMsg);
                            updateStatus(statusMsg, 'success');
                            
                            // Calculate and update dimensions for selected library items
                            // Only if user hasn't modified the code (to avoid overwriting their changes)
                            if (!hasUnsavedChanges && selectedLibraryItems.size > 0) {
                                const selectedFiles = Array.from(selectedLibraryItems)
                                    .map(key => libraryFiles.find(f => getFileKey(f) === key))
                                    .filter(f => f !== undefined);
                                if (selectedFiles.length > 0) {
                                    setTimeout(() => updateDimensionsFromLoadedScene(selectedFiles), 300);
                                }
                            }
                            return;
                        }
                        
                        // If still processing and haven't exceeded max attempts, check again
                        if (attempts < maxAttempts) {
                            setTimeout(checkStatus, 100);
                        } else {
                            // Timeout - check final status
                            const finalStatus = Module.ccall('getStatusMessage', 'string', [], []);
                            if (finalStatus && finalStatus.includes('Error')) {
                                console.error('‚ùå Scene load failed (timeout):', finalStatus);
                                updateStatus(finalStatus, 'error');
                            } else {
                                console.warn('‚ö†Ô∏è Status check timeout, final status:', finalStatus || 'unknown');
                                updateStatus(finalStatus || 'Status unknown - check console for details', 'warning');
                            }
                        }
                    } catch (error) {
                        console.error('‚ùå Error checking status:', error);
                        updateStatus('Error checking status: ' + error.message, 'error');
                    }
                };
                
                // Start checking status after a short delay
                setTimeout(checkStatus, 100);
                } catch (error) {
                console.error('‚ùå Code execution error:', error);
                console.error('Error stack:', error.stack);
                    updateStatus('Error: ' + error.message, 'error');
            }
        }
        
        // Calculate dimensions for library items from the current scene
        function calculateLibraryItemDimensions(selectedFiles) {
            if (!Module || !isInitialized || !selectedFiles || selectedFiles.length === 0) {
                return;
            }
            
            // Don't calculate dimensions if user has unsaved changes - this would execute original code
            if (hasUnsavedChanges) {
                return;
            }
            
            try {
                // Try to get the bounding box from the current scene
                // We need to execute a small snippet that gets the bounding box
                // Since we can't directly access the scene object, we'll need to evaluate code
                // that gets the bounding box from the exported scene
                
                // Get the current code from editor
                const currentCode = editor ? editor.getValue() : '';
                if (!currentCode || !currentCode.includes('export const scene')) {
                    return;
                }
                
                // Create a code snippet to calculate dimensions
                // We'll evaluate the scene and get its bounding box
                const dimensionCode = currentCode + '\n\n// Calculate dimensions\n' +
                    'if (typeof scene !== "undefined" && scene) {\n' +
                    '  const box = boundingBox(scene);\n' +
                    '  const dims = {\n' +
                    '    width: Math.round((box.max[0] - box.min[0]) * 10) / 10,\n' +
                    '    height: Math.round((box.max[1] - box.min[1]) * 10) / 10,\n' +
                    '    depth: Math.round((box.max[2] - box.min[2]) * 10) / 10\n' +
                    '  };\n' +
                    '  console.log("Dimensions:", dims);\n' +
                    '}';
                
                // Execute the dimension calculation code
                // We'll use a temporary file to evaluate this
                try {
                    Module.FS.writeFile('/tmp/dimensions.js', dimensionCode);
                    // Note: This is a simplified approach - in practice, we'd need to 
                    // actually evaluate the code and get the result back
                    // For now, we'll try to get dimensions from the scene that was just loaded
                    
                    // Since we can't easily get the result back from QuickJS evaluation,
                    // we'll store dimensions when we successfully load items
                    // The dimensions will be calculated when items are loaded individually
                    
                } catch (e) {
                    console.warn('‚ö†Ô∏è Could not calculate dimensions:', e);
                }
            } catch (error) {
                console.warn('‚ö†Ô∏è Error calculating dimensions:', error);
            }
        }
        
        // Calculate dimensions for a single library item by loading it temporarily
        async function calculateItemDimensions(file) {
            if (!file || !Module || !isInitialized) {
                return;
            }
            
            // Don't calculate dimensions if user has unsaved changes - this would overwrite their scene
            // This check is critical - dimension calculation executes code which would overwrite user's edits
            if (hasUnsavedChanges && originalCode !== null) {
                console.log(`‚ö†Ô∏è Skipping dimension calculation for ${file.name}: user has unsaved changes`);
                return;
            }
            
            const fileKey = getFileKey(file);
            
            // Check cache first
            try {
                const cached = localStorage.getItem(`dingcad_dims_${fileKey}`);
                if (cached) {
                    const dims = JSON.parse(cached);
                    libraryItemDimensions.set(fileKey, dims);
                    updateLibraryUI();
                    return;
                }
            } catch (e) {
                // Ignore cache errors
            }
            
            // Mark as calculating
            libraryItemDimensions.set(fileKey, { width: null, height: null, depth: null, calculating: true });
            updateLibraryUI();
            
            try {
                // Fetch the file
                const response = await fetch(file.path);
                if (!response.ok) {
                    libraryItemDimensions.delete(fileKey);
                    updateLibraryUI();
                    return;
                }
                const code = await response.text();
                
                // Process the code to ensure it exports a scene
                let processedCode = code;
                
                // Check if it exports scene directly
                if (code.includes('export const scene')) {
                    // Good, already exports scene
                } else if (code.includes('export default')) {
                    // Has default export, need to wrap it
                    const funcMatch = code.match(/export\s+default\s+(\w+)\s*;?/);
                    if (funcMatch) {
                        processedCode = code.replace(/export\s+default\s+\w+\s*;?\s*/g, '') + 
                            `\nconst _tempScene = ${funcMatch[1]}();\n` +
                            `export const scene = _tempScene;`;
                    }
                } else {
                    // Try to find exported function
                    const exportFuncMatch = code.match(/export\s+function\s+(\w+)/);
                    if (exportFuncMatch) {
                        processedCode = code + `\n\nconst _tempScene = ${exportFuncMatch[1]}();\n` +
                            `export const scene = _tempScene;`;
                    } else {
                        // Can't determine how to execute, skip
                        libraryItemDimensions.delete(fileKey);
                        updateLibraryUI();
                        return;
                    }
                }
                
                // Add dimension calculation code that uses print with special marker
                // We'll intercept the module's print callback to capture dimensions
                const dimensionCode = processedCode + '\n\n' +
                    '// Calculate dimensions\n' +
                    'if (typeof scene !== "undefined" && scene) {\n' +
                    '  try {\n' +
                    '    const box = boundingBox(scene);\n' +
                    '    const width = Math.round((box.max[0] - box.min[0]) * 10) / 10;\n' +
                    '    const height = Math.round((box.max[1] - box.min[1]) * 10) / 10;\n' +
                    '    const depth = Math.round((box.max[2] - box.min[2]) * 10) / 10;\n' +
                    '    // Print dimensions with special marker for capture\n' +
                    '    print("DINGCAD_DIMS:" + JSON.stringify({width, height, depth}));\n' +
                    '  } catch (e) {\n' +
                    '    // Ignore errors\n' +
                    '  }\n' +
                    '}';
                
                // Intercept console.log to capture dimensions from print output
                // The module's print callback calls console.log, so we intercept that
                const originalConsoleLog = console.log;
                let dimensions = null;
                
                // Create a wrapper that captures our special marker
                console.log = function(...args) {
                    originalConsoleLog.apply(console, args);
                    const text = args.join(' ');
                    if (typeof text === 'string' && text.includes('DINGCAD_DIMS:')) {
                        try {
                            const startIdx = text.indexOf('DINGCAD_DIMS:');
                            const dimsJson = text.substring(startIdx + 'DINGCAD_DIMS:'.length).trim();
                            dimensions = JSON.parse(dimsJson);
                        } catch (e) {
                            // Ignore parse errors
                        }
                    }
                };
                
                try {
                    // Execute the code
                    Module.ccall('loadSceneFromCode', null, ['string'], [dimensionCode]);
                    
                    // Wait for execution to complete and print callback to fire
                    // Give it enough time for the scene to load and dimensions to be calculated
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    
                    // Restore console.log
                    console.log = originalConsoleLog;
                    
                    if (dimensions && dimensions.width !== undefined && !isNaN(dimensions.width)) {
                        libraryItemDimensions.set(fileKey, dimensions);
                        // Cache dimensions
                        try {
                            localStorage.setItem(`dingcad_dims_${fileKey}`, JSON.stringify(dimensions));
                        } catch (e) {
                            // Ignore cache errors
                        }
                        updateLibraryUI();
                    } else {
                        libraryItemDimensions.delete(fileKey);
                        updateLibraryUI();
                    }
                } catch (e) {
                    // Restore console.log on error
                    console.log = originalConsoleLog;
                    libraryItemDimensions.delete(fileKey);
                    updateLibraryUI();
                    console.warn(`‚ö†Ô∏è Could not calculate dimensions for ${file.name}:`, e);
                }
            } catch (error) {
                libraryItemDimensions.delete(fileKey);
                updateLibraryUI();
                console.warn(`‚ö†Ô∏è Could not calculate dimensions for ${file.name}:`, error);
            }
        }
        
        // Update dimensions from the current scene after successful load
        function updateDimensionsFromLoadedScene(selectedFiles) {
            if (!Module || !isInitialized || !selectedFiles || selectedFiles.length === 0) {
                return;
            }
            
            // Don't calculate dimensions if user has unsaved changes - this would execute original code
            if (hasUnsavedChanges) {
                return;
            }
            
            // For single file, calculate dimensions by loading it individually
            if (selectedFiles.length === 1) {
                const file = selectedFiles[0];
                const fileKey = getFileKey(file);
                
                // Only calculate if not already cached
                if (!libraryItemDimensions.has(fileKey)) {
                    calculateItemDimensions(file);
                }
            } else {
                // Multiple files - we can't easily get individual dimensions when combined
                // So we'll calculate dimensions for each file individually in the background
                selectedFiles.forEach(file => {
                    const fileKey = getFileKey(file);
                    if (!libraryItemDimensions.has(fileKey)) {
                        // Calculate in background
                        setTimeout(() => calculateItemDimensions(file), 100);
                    }
                });
            }
        }
        
        
        document.getElementById('edit-btn').addEventListener('click', () => {
            const panel = document.getElementById('code-editor-panel');
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                panel.classList.add('minimized');
            } else {
                // Toggle expand/minimize
                toggleCodeEditorPanel();
            }
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            if (Module && Module.ccall) {
                Module.ccall('resetCamera', null, [], []);
                // Update URL after reset
                setTimeout(() => {
                    const cameraState = getCameraState();
                    if (cameraState) {
                        // Get currently selected items to preserve them
                        const selectedFiles = Array.from(selectedLibraryItems)
                            .map(fileKey => libraryFiles.find(file => getFileKey(file) === fileKey))
                            .filter(file => file !== undefined);
                        updateURL(selectedFiles.length > 0 ? selectedFiles : null, cameraState);
                    }
                }, 100);
            }
        });
        
        // Library panel functionality - dynamically loaded from manifest
        let libraryFiles = [];
        let libraryPanelVisible = false;
        let selectedLibraryItems = new Set(); // Track selected library items by fileKey
        let libraryItemDimensions = new Map(); // Cache dimensions for each library item (fileKey -> {width, height, depth})
        
        // Load library manifest dynamically
        async function loadLibraryManifest() {
            try {
                console.log('üìö Loading library manifest...');
                const response = await fetch('./library-manifest.json');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const manifest = await response.json();
                libraryFiles = manifest.files || [];
                console.log(`‚úÖ Loaded ${libraryFiles.length} library files from manifest`);
                // Repopulate the library list with new data
                populateLibraryList();
            } catch (error) {
                console.error('‚ùå Failed to load library manifest:', error);
                console.warn('‚ö†Ô∏è Falling back to empty library list');
                libraryFiles = [];
                populateLibraryList();
            }
        }
        
        function toggleLibraryPanel() {
            libraryPanelVisible = !libraryPanelVisible;
            const panel = document.getElementById('library-panel');
            if (libraryPanelVisible) {
                panel.classList.add('visible');
            } else {
                panel.classList.remove('visible');
            }
        }
        
        // URL management functions
        function updateURL(libraryItems = null, cameraState = null, preserveParams = true) {
            const url = new URL(window.location);
            
            // If preserveParams is false, clear camera params first (only when setting library items)
            if (!preserveParams && libraryItems !== null) {
                url.searchParams.delete('yaw');
                url.searchParams.delete('pitch');
                url.searchParams.delete('distance');
                url.searchParams.delete('tx');
                url.searchParams.delete('ty');
                url.searchParams.delete('tz');
            }
            
            // Handle library items - only update if libraryItems is explicitly provided (not null)
            // If libraryItems is null, preserve existing items in URL
            if (libraryItems !== null) {
                // Explicitly setting library items - clear old ones first
                url.searchParams.delete('item');
                url.searchParams.delete('items');
                
                if (libraryItems.length > 0) {
                    if (libraryItems.length === 1) {
                        // Single item - use 'item' for backward compatibility
                        const fileKey = libraryItems[0].path || `${libraryItems[0].folder || 'root'}/${libraryItems[0].name}`;
                        url.searchParams.set('item', fileKey);
                    } else {
                        // Multiple items - use 'items' parameter (comma-separated)
                        const fileKeys = libraryItems.map(item => 
                            item.path || `${item.folder || 'root'}/${item.name}`
                        );
                        url.searchParams.set('items', fileKeys.join(','));
                    }
                }
            }
            // If libraryItems is null, we preserve existing item/items params (don't delete them)
            
            if (cameraState !== null) {
                if (cameraState.yaw !== undefined) url.searchParams.set('yaw', cameraState.yaw.toFixed(4));
                if (cameraState.pitch !== undefined) url.searchParams.set('pitch', cameraState.pitch.toFixed(4));
                if (cameraState.distance !== undefined) url.searchParams.set('distance', cameraState.distance.toFixed(4));
                if (cameraState.target !== undefined) {
                    url.searchParams.set('tx', cameraState.target.x.toFixed(4));
                    url.searchParams.set('ty', cameraState.target.y.toFixed(4));
                    url.searchParams.set('tz', cameraState.target.z.toFixed(4));
                }
            }
            
            // Update URL without page reload
            window.history.replaceState({}, '', url);
        }
        
        // Get file key for a library item
        function getFileKey(file) {
            return file.path || `${file.folder || 'root'}/${file.name}`;
        }
        
        // Cache for camera target buffer to avoid repeated allocations
        let cameraTargetBuffer = null;
        
        function getCameraState() {
            if (!Module || !Module.ccall) return null;
            try {
                const yaw = Module.ccall('getCameraYaw', 'number', [], []);
                const pitch = Module.ccall('getCameraPitch', 'number', [], []);
                const distance = Module.ccall('getCameraDistance', 'number', [], []);
                const target = { x: 0, y: 0, z: 0 };
                
                // Allocate memory for return values (3 floats) - use cached buffer if possible
                let targetPtr = null;
                let usedMalloc = false;
                
                // Try _malloc first (requires explicit freeing)
                if (typeof Module._malloc === 'function' && typeof Module._free === 'function') {
                    try {
                        targetPtr = Module._malloc(12); // 3 floats * 4 bytes
                        usedMalloc = true;
                    } catch (e) {
                        // Fall through to next option
                    }
                }
                
                // Try stackAlloc (doesn't require freeing, but may not be exported)
                if (!targetPtr) {
                    try {
                        // Check if property exists first to avoid abort if not exported
                        if ('stackAlloc' in Module && typeof Module.stackAlloc === 'function') {
                            targetPtr = Module.stackAlloc(12);
                        }
                    } catch (e) {
                        // stackAlloc not available or not exported, continue to next option
                    }
                }
                
                // Try allocate as fallback
                if (!targetPtr && typeof Module.allocate === 'function') {
                    try {
                        targetPtr = Module.allocate(12, 'i8', Module.ALLOC_NORMAL);
                    } catch (e) {
                        // Fall through
                    }
                }
                
                // If no allocation method worked, return with default target values
                if (!targetPtr) {
                    return { yaw, pitch, distance, target };
                }
                
                try {
                    // Call with pointers as arguments
                    Module.ccall('getCameraTarget', null, ['number', 'number', 'number'], 
                        [targetPtr, targetPtr + 4, targetPtr + 8]);
                    
                    // Read values from memory - use getValue if available, otherwise HEAPF32
                    if (typeof Module.getValue === 'function') {
                        target.x = Module.getValue(targetPtr, 'float');
                        target.y = Module.getValue(targetPtr + 4, 'float');
                        target.z = Module.getValue(targetPtr + 8, 'float');
                    } else if (Module.HEAPF32) {
                        // Fallback to HEAPF32
                        target.x = Module.HEAPF32[targetPtr / 4];
                        target.y = Module.HEAPF32[(targetPtr + 4) / 4];
                        target.z = Module.HEAPF32[(targetPtr + 8) / 4];
                    }
                } finally {
                    // Free memory (only if we used malloc, not stackAlloc)
                    if (usedMalloc && typeof Module._free === 'function') {
                        try {
                            Module._free(targetPtr);
                        } catch (e) {
                            // Ignore errors during free
                        }
                    } else if (typeof Module.deallocate === 'function') {
                        try {
                            Module.deallocate(targetPtr);
                        } catch (e) {
                            // Ignore errors during deallocate
                        }
                    }
                    // stackAlloc doesn't need freeing
                }
                
                return { yaw, pitch, distance, target };
            } catch (e) {
                console.warn('‚ö†Ô∏è Error getting camera state:', e);
                return null;
            }
        }
        
        function setCameraState(state) {
            if (!Module || !Module.ccall) return false;
            try {
                if (state.yaw !== undefined) Module.ccall('setCameraYaw', null, ['number'], [state.yaw]);
                if (state.pitch !== undefined) Module.ccall('setCameraPitch', null, ['number'], [state.pitch]);
                if (state.distance !== undefined) Module.ccall('setCameraDistance', null, ['number'], [state.distance]);
                if (state.target !== undefined) {
                    Module.ccall('setCameraTarget', null, ['number', 'number', 'number'], 
                        [state.target.x, state.target.y, state.target.z]);
                }
                Module.ccall('updateCameraPosition', null, [], []);
                return true;
            } catch (e) {
                console.warn('‚ö†Ô∏è Error setting camera state:', e);
                return false;
            }
        }
        
        // Debounced camera update function
        let cameraUpdateTimeout = null;
        function updateCameraInURL() {
            if (cameraUpdateTimeout) clearTimeout(cameraUpdateTimeout);
            cameraUpdateTimeout = setTimeout(() => {
                const cameraState = getCameraState();
                if (cameraState) {
                    // Preserve current library items when updating camera
                    const selectedFiles = Array.from(selectedLibraryItems)
                        .map(key => libraryFiles.find(f => getFileKey(f) === key))
                        .filter(f => f !== undefined);
                    updateURL(selectedFiles.length > 0 ? selectedFiles : null, cameraState, true);
                }
            }, 300); // 300ms debounce
        }
        
        // Toggle library item selection
        function toggleLibraryItem(file) {
            // Check if user has unsaved changes before loading new library item
            if (hasUnsavedChanges && originalCode !== null) {
                const confirmed = confirm(
                    'You have unsaved changes to your code. Loading a library item will overwrite your changes.\n\n' +
                    'Would you like to continue? (Click Cancel to keep your current code, or OK to load the library item)'
                );
                if (!confirmed) {
                    return; // User cancelled, don't change selection
                }
            }
            
            const fileKey = getFileKey(file);
            if (selectedLibraryItems.has(fileKey)) {
                selectedLibraryItems.delete(fileKey);
            } else {
                selectedLibraryItems.add(fileKey);
            }
            updateLibraryUI();
            // Update URL immediately when items are toggled
            const selectedFiles = Array.from(selectedLibraryItems)
                .map(key => libraryFiles.find(f => getFileKey(f) === key))
                .filter(f => f !== undefined);
            const currentCameraState = getCameraState();
            updateURL(selectedFiles.length > 0 ? selectedFiles : [], currentCameraState, true);
            loadSelectedLibraryItems();
        }
        
        // Load all selected library items and combine them
        function loadSelectedLibraryItems(openPanel = false) {
            // Check if user has unsaved changes and warn them
            if (hasUnsavedChanges && originalCode !== null) {
                const confirmed = confirm(
                    'You have unsaved changes to your code. Loading a library item will overwrite your changes.\n\n' +
                    'Would you like to continue? (Click Cancel to keep your current code, or OK to load the library item)'
                );
                if (!confirmed) {
                    return; // User cancelled, don't load library item
                }
                // User confirmed, proceed with loading
            }
            
                if (selectedLibraryItems.size === 0) {
                // No items selected - clear the scene
                if (editor) {
                    setEditorCode('// No library items selected\n// Select items from the library to load them', true);
                    updateEditorTitle(null);
                    if (Module && isInitialized) {
                        executeCode();
                    }
                }
                // Update URL to remove items
                const currentCameraState = getCameraState();
                updateURL([], currentCameraState, true);
                return;
            }
            
            // Get selected files
            const selectedFiles = Array.from(selectedLibraryItems)
                .map(fileKey => libraryFiles.find(file => getFileKey(file) === fileKey))
                .filter(file => file !== undefined);
            
            if (selectedFiles.length === 0) {
                console.warn('‚ö†Ô∏è No valid files found for selected items');
                return;
            }
            
            console.log(`üìö Loading ${selectedFiles.length} library file(s): ${selectedFiles.map(f => f.name).join(', ')}`);
            
            // Update URL with selected items (preserve existing camera params)
            const currentCameraState = getCameraState();
            updateURL(selectedFiles, currentCameraState, true);
            
            // Store selected items in localStorage
            try {
                const fileKeys = selectedFiles.map(f => getFileKey(f));
                localStorage.setItem('dingcad_last_library_items', JSON.stringify(fileKeys));
            } catch (e) {
                console.warn('‚ö†Ô∏è Could not save to localStorage:', e);
            }
            
            // Load all files in parallel
            Promise.all(selectedFiles.map(file => 
            fetch(file.path)
                .then(r => {
                    if (!r.ok) {
                        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
                    }
                    return r.text();
                })
                    .then(code => ({ file, code }))
            )).then(fileData => {
                console.log(`‚úÖ Loaded ${fileData.length} file(s)`);
                
                // Process each file's code
                const processedCodes = fileData.map(({ file, code }) => {
                    let finalCode = code;
                    
                    // Check if the file exports scene directly
                    if (code.includes('export const scene')) {
                        console.log(`  ‚Üí ${file.name} exports scene directly`);
                        return finalCode;
                    }
                    
                    // File exports functions - need to handle default export
                    console.log(`  ‚Üí ${file.name} exports functions, checking for default export...`);
                        
                        // Check if there's already a default export
                        if (code.includes('export default')) {
                        console.log(`  ‚Üí ${file.name} has default export`);
                        return finalCode;
                    }
                    
                            // No default export, need to create one from named export
                            let functionName = null;
                            
                            // Try to find exported function names
                            const exportFuncMatch = code.match(/export\s+function\s+(\w+)/);
                            if (exportFuncMatch) {
                                functionName = exportFuncMatch[1];
                                console.log(`  ‚Üí Found named export function: ${functionName}`);
                            }
                            
                            // Fallback to filename-based detection
                            if (!functionName) {
                                if (file.name.includes('xiao')) {
                                    functionName = 'buildXiaoEsp32C3';
                                } else if (file.name.includes('DTSPCB')) {
                                    functionName = 'buildDTSPCB';
                                } else if (file.name.includes('radio')) {
                                    functionName = 'buildRadioEnclosure';
                                } else if (file.name.includes('ifItFitsIsits')) {
                                    functionName = 'ifItFitsIsitsBox';
                                } else {
                                    functionName = 'buildDTSPCB'; // default fallback
                                }
                                console.log(`  ‚Üí Using filename-based function name: ${functionName}`);
                            }
                            
                            // Create default export that calls the function
                            finalCode = code + '\n\n// Auto-generated: create default export that calls the function\n' +
                                `export default ${functionName};`;
                            
                    return finalCode;
                });
                
                // Combine all codes into a single module
                let combinedCode = '';
                
                if (processedCodes.length === 1) {
                    // Single file - use as-is
                    combinedCode = processedCodes[0];
                } else {
                    // Multiple files - combine them
                    // We'll rename scenes to avoid conflicts and combine them at the end
                    const sceneNames = [];
                    
                    processedCodes.forEach((code, index) => {
                        const file = fileData[index].file;
                        const sceneName = `scene${index}`;
                        
                        // Check if code exports a scene directly
                        if (code.includes('export const scene')) {
                            // Rename the scene export to avoid conflicts
                            // Replace all occurrences of 'export const scene' with 'const sceneName'
                            const renamedCode = code.replace(/export\s+const\s+scene\b/g, `const ${sceneName}`);
                            combinedCode += `// ====== ${file.name} ======\n${renamedCode}\n\n`;
                            sceneNames.push(sceneName);
                        } else if (code.includes('export default')) {
                            // Extract default export function name
                            const funcMatch = code.match(/export\s+default\s+(\w+)\s*;?/);
                            if (funcMatch) {
                                const funcName = funcMatch[1];
                                // Remove the export default line and call the function
                                const modifiedCode = code.replace(/export\s+default\s+\w+\s*;?\s*/g, '');
                                combinedCode += `// ====== ${file.name} ======\n${modifiedCode}\nconst ${sceneName} = ${funcName}();\n\n`;
                                sceneNames.push(sceneName);
                            } else {
                                // Default export might be inline - try to handle it
                                const modifiedCode = code.replace(/export\s+default\s*/, `const ${sceneName} = `);
                                combinedCode += `// ====== ${file.name} ======\n${modifiedCode}\n\n`;
                                sceneNames.push(sceneName);
                            }
                        } else {
                            // No export found - use code as-is
                            combinedCode += `// ====== ${file.name} ======\n${code}\n\n`;
                            // Try to find if there's a scene variable defined
                            const sceneMatch = code.match(/(?:const|let|var)\s+scene\s*=/);
                            if (sceneMatch) {
                                // There's a scene variable - rename it
                                const renamedCode = code.replace(/(?:const|let|var)\s+scene\b/g, `const ${sceneName}`);
                                // Replace the last occurrence in combinedCode
                                const lastIndex = combinedCode.lastIndexOf(`// ====== ${file.name} ======`);
                                if (lastIndex !== -1) {
                                    const before = combinedCode.substring(0, lastIndex);
                                    const after = combinedCode.substring(lastIndex);
                                    combinedCode = before + after.replace(code, renamedCode);
                                }
                                sceneNames.push(sceneName);
                            } else {
                                // Assume the code creates a scene somehow - use a fallback
                                sceneNames.push(sceneName);
                            }
                        }
                    });
                    
                    // Combine all scenes using union (built-in function)
                    if (sceneNames.length > 0) {
                        combinedCode += `\n// ====== Combined Scene ======\n`;
                        if (sceneNames.length === 1) {
                            combinedCode += `export const scene = ${sceneNames[0]};\n`;
                        } else {
                            // Use union to combine multiple scenes
                            combinedCode += `export const scene = union(${sceneNames.join(', ')});\n`;
                        }
                    } else {
                        // Fallback: just export the first scene if no scenes found
                        combinedCode += `\nexport const scene = scene0;\n`;
        }
                    }
        
                    if (editor) {
                    setEditorCode(combinedCode, true); // Mark as user action to set original code
                    console.log('  ‚Üí Combined code loaded into editor');
                    }
                
                // Update editor title
                const title = selectedFiles.length === 1 
                    ? selectedFiles[0].name 
                    : `${selectedFiles.length} items selected`;
                updateEditorTitle(title);
                
                // Save initial version
                    if (editor) {
                        const code = editor.getValue();
                    saveVersion(code, title);
                    }
                
                // Ensure editor panel is visible
                    const panel = document.getElementById('code-editor-panel');
                    panel.classList.remove('hidden');
                    if (!panel.classList.contains('expanded')) {
                        panel.classList.remove('expanded');
                        panel.classList.add('minimized');
                    }
                
                    // Syntax highlighting is already handled by setEditorCode
                    // Just ensure layout is correct
                    if (editor && !useFallbackEditor) {
                        setTimeout(() => {
                            editor.layout();
                            editor.render(true);
                        }, 150);
                    }
                
                // Execute code
                    setTimeout(() => {
                        if (!Module || !isInitialized) {
                            console.warn('‚ö†Ô∏è Module not ready yet, waiting...');
                            let attempts = 0;
                            const checkReady = setInterval(() => {
                                attempts++;
                                if (Module && isInitialized) {
                                    clearInterval(checkReady);
                                    executeCode();
                                    // Calculate dimensions after code execution (only if no unsaved changes)
                                    if (!hasUnsavedChanges) {
                                        setTimeout(() => calculateLibraryItemDimensions(selectedFiles), 500);
                                    }
                            } else if (attempts > 20) {
                                    clearInterval(checkReady);
                                    updateStatus('Error: Module initialization timeout', 'error');
                                    console.error('‚ùå Module failed to initialize after timeout');
                                }
                            }, 100);
                        } else {
                            executeCode();
                            // Calculate dimensions after code execution (only if no unsaved changes)
                            if (!hasUnsavedChanges) {
                                setTimeout(() => calculateLibraryItemDimensions(selectedFiles), 500);
                            }
                        }
                    }, 50);
                
                // Only open library panel if requested
                    if (openPanel) {
                        toggleLibraryPanel();
                    }
            }).catch(err => {
                const errorMsg = `Error loading library files: ${err.message}`;
                    console.error('‚ùå Library load error:', err);
                    updateStatus(errorMsg, 'error');
                });
        }
        
        // Legacy function for single file loading (backward compatibility)
        function loadLibraryFile(file, openPanel = true) {
            const fileKey = getFileKey(file);
            // Clear all selections and select only this file
            selectedLibraryItems.clear();
            selectedLibraryItems.add(fileKey);
            updateLibraryUI();
            loadSelectedLibraryItems(openPanel);
        }
        
        // Update library UI to reflect selected items
        function updateLibraryUI() {
            // Update selected state in the library list
            const items = document.querySelectorAll('.library-item');
            items.forEach(item => {
                const fileKey = item.dataset.fileKey;
                if (fileKey) {
                    if (selectedLibraryItems.has(fileKey)) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                }
            });
            
            // Also update URL to reflect current selection
            if (libraryFiles && libraryFiles.length > 0) {
                const selectedFiles = Array.from(selectedLibraryItems)
                    .map(key => libraryFiles.find(f => getFileKey(f) === key))
                    .filter(f => f !== undefined);
                const currentCameraState = getCameraState();
                if (currentCameraState || selectedFiles.length > 0) {
                    updateURL(selectedFiles.length > 0 ? selectedFiles : [], currentCameraState, true);
                }
            }
        }
        
        function populateLibraryList() {
            const list = document.getElementById('library-list');
            if (!list) {
                console.error('‚ùå Library list element not found');
                return;
            }
            
            list.innerHTML = '';
            
            if (!libraryFiles || libraryFiles.length === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No library files found</div>';
                console.warn('‚ö†Ô∏è No library files to display');
                return;
            }
            
            console.log(`üìö Populating library list with ${libraryFiles.length} files`);
            
            // Group files by folder
            const grouped = {};
            libraryFiles.forEach(file => {
                const folder = file.folder || 'root';
                if (!grouped[folder]) {
                    grouped[folder] = [];
                }
                grouped[folder].push(file);
            });
            
            // Sort folders (root first, then alphabetically)
            const folders = Object.keys(grouped).sort((a, b) => {
                if (a === 'root') return -1;
                if (b === 'root') return 1;
                return a.localeCompare(b);
            });
            
            // Render grouped files
            folders.forEach(folder => {
                const files = grouped[folder];
                
                // Add folder header if not root
                if (folder !== 'root') {
                    const folderHeader = document.createElement('div');
                    folderHeader.className = 'library-folder-header';
                    folderHeader.textContent = folder + '/';
                    list.appendChild(folderHeader);
                }
                
                // Add files in this folder
                files.forEach(file => {
                    const fileKey = getFileKey(file);
                    const item = document.createElement('div');
                    item.className = 'library-item';
                    item.dataset.fileKey = fileKey;
                    
                    const isSelected = selectedLibraryItems.has(fileKey);
                    const dims = libraryItemDimensions.get(fileKey);
                    let dimsText = '';
                    
                    if (dims) {
                        if (dims.calculating) {
                            dimsText = '<div class="library-item-dims">Calculating dimensions...</div>';
                        } else if (dims.width !== null && dims.height !== null && dims.depth !== null) {
                            dimsText = `<div class="library-item-dims">${dims.width.toFixed(1)} √ó ${dims.height.toFixed(1)} √ó ${dims.depth.toFixed(1)} mm</div>`;
                        }
                    }
                    
                    item.innerHTML = `
                        <div style="flex: 1;">
                        <div class="library-item-name">${file.name}</div>
                        <div class="library-item-desc">${file.desc || 'No description'}</div>
                        ${dimsText}
                        </div>
                    `;
                    
                    // Handle item click (toggle selection)
                    item.addEventListener('click', () => {
                        toggleLibraryItem(file);
                    });
                    
                    if (isSelected) {
                        item.classList.add('selected');
                    }
                    
                    list.appendChild(item);
                    
                    // Calculate dimensions for this item if not already cached
                    if (!dims && Module && isInitialized) {
                        // Calculate dimensions after a delay to avoid blocking UI
                        // Use a longer delay for items further down the list to avoid overwhelming the system
                        // IMPORTANT: Check for unsaved changes before scheduling, and also check inside the timeout
                        const delay = Math.min(100 + (list.children.length * 50), 2000);
                        setTimeout(() => {
                            // Double-check unsaved changes before executing (in case user edited code during delay)
                            if (!hasUnsavedChanges || originalCode === null) {
                                calculateItemDimensions(file);
                            } else {
                                console.log(`‚ö†Ô∏è Skipping dimension calculation for ${file.name}: user has unsaved changes`);
                            }
                        }, delay);
                    }
                });
            });
            
            console.log(`‚úÖ Library list populated with ${folders.length} folders`);
            
            // Update UI to reflect any pre-selected items (e.g., from URL or localStorage)
            updateLibraryUI();
        }
        
        document.getElementById('library-toggle').addEventListener('click', toggleLibraryPanel);
        document.getElementById('library-close').addEventListener('click', toggleLibraryPanel);
        
        // Version history panel controls (hidden from toolbar, but still accessible via close button)
        document.getElementById('version-history-close').addEventListener('click', toggleVersionHistoryPanel);
        
        // Load version history on startup
        loadVersionHistory();
        
        // Function to parse URL and restore state
        function parseURLAndRestoreState() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // Parse camera state from URL
            const yaw = urlParams.get('yaw');
            const pitch = urlParams.get('pitch');
            const distance = urlParams.get('distance');
            const tx = urlParams.get('tx');
            const ty = urlParams.get('ty');
            const tz = urlParams.get('tz');
            
            if (yaw !== null || pitch !== null || distance !== null || tx !== null || ty !== null || tz !== null) {
                const cameraState = {};
                if (yaw !== null) cameraState.yaw = parseFloat(yaw);
                if (pitch !== null) cameraState.pitch = parseFloat(pitch);
                if (distance !== null) cameraState.distance = parseFloat(distance);
                if (tx !== null || ty !== null || tz !== null) {
                    cameraState.target = {
                        x: tx !== null ? parseFloat(tx) : 0,
                        y: ty !== null ? parseFloat(ty) : 0,
                        z: tz !== null ? parseFloat(tz) : 0
                    };
                }
                
                // Restore camera state after module is ready
                if (Module && isInitialized) {
                    setCameraState(cameraState);
                    console.log('‚úÖ Restored camera state from URL:', cameraState);
                } else {
                    // Wait for module to be ready
                    const checkReady = setInterval(() => {
                        if (Module && isInitialized) {
                            clearInterval(checkReady);
                            setCameraState(cameraState);
                            console.log('‚úÖ Restored camera state from URL:', cameraState);
                        }
                    }, 100);
                    // Timeout after 5 seconds
                    setTimeout(() => clearInterval(checkReady), 5000);
                }
            }
            
            // Parse library items from URL (support both 'item' and 'items' parameters)
            const itemKey = urlParams.get('item');
            const itemsKey = urlParams.get('items');
            
            let itemsToLoad = [];
            
            if (itemsKey && libraryFiles && libraryFiles.length > 0) {
                // Multiple items - comma-separated
                const itemKeys = itemsKey.split(',').map(k => k.trim()).filter(k => k);
                itemsToLoad = itemKeys
                    .map(key => findMatchingLibraryFile(key, libraryFiles))
                    .filter(file => file !== null && file !== undefined);
            } else if (itemKey && libraryFiles && libraryFiles.length > 0) {
                // Single item (backward compatibility)
                const matchingFile = findMatchingLibraryFile(itemKey, libraryFiles);
                if (matchingFile) {
                    itemsToLoad = [matchingFile];
                }
            }
            
            if (itemsToLoad.length > 0) {
                console.log(`‚úÖ Found ${itemsToLoad.length} library item(s) in URL: ${itemsToLoad.map(f => f.name).join(', ')}, loading...`);
                
                // Check if user has unsaved changes - if so, don't auto-load from URL
                // This prevents overwriting user's modified code when URL is parsed
                if (hasUnsavedChanges && originalCode !== null) {
                    console.log('‚ö†Ô∏è User has unsaved changes, skipping auto-load from URL to preserve edits');
                    // Still update selected items in UI for reference, but don't load the code
                    selectedLibraryItems.clear();
                    itemsToLoad.forEach(file => {
                        selectedLibraryItems.add(getFileKey(file));
                    });
                    updateLibraryUI();
                    return true; // Return true to indicate URL was parsed, but don't load code
                }
                
                // Set selected items
                selectedLibraryItems.clear();
                itemsToLoad.forEach(file => {
                    selectedLibraryItems.add(getFileKey(file));
                });
                // Update UI immediately (will also update URL)
                updateLibraryUI();
                
                // Load them after module is ready (don't open library panel when loading from URL)
                const loadItems = () => {
                    loadSelectedLibraryItems(false);
                };
                
                    if (Module && isInitialized) {
                    setTimeout(loadItems, 500);
                    } else {
                        const checkReady = setInterval(() => {
                            if (Module && isInitialized) {
                                clearInterval(checkReady);
                            setTimeout(loadItems, 500);
                            }
                        }, 100);
                        setTimeout(() => clearInterval(checkReady), 5000);
                    }
                return true; // URL items take precedence
            }
            
            return false; // No URL items, fall back to localStorage
        }
        
        // Helper function to normalize and match file paths
        function findMatchingLibraryFile(searchKey, libraryFiles) {
            if (!searchKey || !libraryFiles || libraryFiles.length === 0) return null;
            
            // Decode and normalize the search key
            const decodedKey = decodeURIComponent(searchKey);
            const normalizedKey = decodedKey.replace(/^\.\//, '').replace(/^\/+/, '');
            
            return libraryFiles.find(file => {
                const fileKey = file.path || `${file.folder || 'root'}/${file.name}`;
                const normalizedFileKey = fileKey.replace(/^\.\//, '').replace(/^\/+/, '');
                
                // Try multiple matching strategies
                return normalizedFileKey === normalizedKey ||
                       fileKey === decodedKey ||
                       file.path === decodedKey ||
                       file.path === normalizedKey ||
                       file.name === decodedKey ||
                       file.name === normalizedKey.split('/').pop() ||
                       `${file.folder || 'root'}/${file.name}` === normalizedKey ||
                       `${file.folder || 'root'}/${file.name}` === decodedKey;
            });
        }
        
        // Function to auto-load the last library item(s)
        function autoLoadLastLibraryItem() {
            // Check URL first, if it has items, use that instead
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('item') || urlParams.get('items')) {
                console.log('‚ÑπÔ∏è URL has item(s) parameter, skipping localStorage auto-load');
                return false;
            }
            
            if (!Module || !isInitialized || !libraryFiles || libraryFiles.length === 0) {
                console.log('‚è≥ Waiting for module and library to be ready...');
                return false;
            }
            
            try {
                // Try to load multiple items first (new format)
                const lastItemsJson = localStorage.getItem('dingcad_last_library_items');
                if (lastItemsJson) {
                    try {
                        const lastItemKeys = JSON.parse(lastItemsJson);
                        if (Array.isArray(lastItemKeys) && lastItemKeys.length > 0) {
                            console.log(`üîç Looking for saved library items: ${lastItemKeys.join(', ')}`);
                            
                            const matchingFiles = lastItemKeys
                                .map(key => findMatchingLibraryFile(key, libraryFiles))
                                .filter(file => file !== null && file !== undefined);
                            
                            if (matchingFiles.length > 0) {
                                console.log(`‚úÖ Found ${matchingFiles.length} saved library item(s), auto-loading...`);
                                
                                // Set selected items
                                selectedLibraryItems.clear();
                                matchingFiles.forEach(file => {
                                    selectedLibraryItems.add(getFileKey(file));
                                });
                                // Update UI immediately (will also update URL)
                                updateLibraryUI();
                                
                                // Load them after a short delay
                                setTimeout(() => {
                                    loadSelectedLibraryItems();
                                }, 500);
                                return true;
                            } else {
                                console.log(`‚ö†Ô∏è Saved library items not found in manifest`);
                                localStorage.removeItem('dingcad_last_library_items');
                }
                        }
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Error parsing saved library items:', e);
                        localStorage.removeItem('dingcad_last_library_items');
                    }
                }
                
                // Fall back to single item (backward compatibility)
                const lastItemKey = localStorage.getItem('dingcad_last_library_item');
                if (lastItemKey) {
                console.log(`üîç Looking for saved library item: ${lastItemKey}`);
                
                const matchingFile = findMatchingLibraryFile(lastItemKey, libraryFiles);
                
                if (matchingFile) {
                    console.log(`‚úÖ Found saved library item: ${matchingFile.name}, auto-loading...`);
                        
                        // Check if user has unsaved changes - if so, don't auto-load
                        if (hasUnsavedChanges && originalCode !== null) {
                            console.log('‚ö†Ô∏è User has unsaved changes, skipping auto-load from localStorage to preserve edits');
                            // Still update selected items in UI for reference, but don't load the code
                            selectedLibraryItems.clear();
                            selectedLibraryItems.add(getFileKey(matchingFile));
                            updateLibraryUI();
                            return true; // Return true to indicate item was found, but don't load code
                        }
                        
                        // Set selected item
                        selectedLibraryItems.clear();
                        selectedLibraryItems.add(getFileKey(matchingFile));
                        // Update UI immediately (will also update URL)
                        updateLibraryUI();
                        
                        // Load it after a short delay
                    setTimeout(() => {
                            loadSelectedLibraryItems();
                    }, 500);
                    return true;
                } else {
                    console.log(`‚ö†Ô∏è Saved library item not found in manifest: ${lastItemKey}`);
                    localStorage.removeItem('dingcad_last_library_item');
                    return false;
                }
                }
                
                console.log('‚ÑπÔ∏è No saved library items found');
                return false;
            } catch (e) {
                console.warn('‚ö†Ô∏è Error auto-loading last library items:', e);
                return false;
            }
        }
        
        // Initialize on page load
        let moduleInitialized = false;
        let manifestLoaded = false;
        let autoLoadAttempted = false; // Track if we've already tried to auto-load (prevent multiple attempts)
        
        function checkAndAutoLoad() {
            // Only auto-load once on initial page load
            if (autoLoadAttempted) {
                return;
            }
            
            if (moduleInitialized && manifestLoaded) {
                autoLoadAttempted = true; // Mark as attempted
                // Both are ready, try to parse URL and restore state
                setTimeout(() => {
                    // Only auto-load if user doesn't have unsaved changes
                    // This prevents overwriting user's edits when page is reloaded
                    if (!hasUnsavedChanges) {
                        const urlRestored = parseURLAndRestoreState();
                        // If URL didn't have an item, fall back to localStorage
                        if (!urlRestored) {
                            autoLoadLastLibraryItem();
                        }
                    } else {
                        console.log('‚ö†Ô∏è Skipping auto-load: user has unsaved changes');
                    }
                }, 500);
            }
        }
        
        // Track camera changes and update URL
        let lastCameraState = null;
        function trackCameraChanges() {
            if (!Module || !isInitialized) return;
            
            const currentState = getCameraState();
            if (!currentState) return;
            
            // Check if camera state changed significantly
            if (lastCameraState) {
                const threshold = 0.001; // Small threshold to avoid constant updates
                const changed = 
                    Math.abs(currentState.yaw - lastCameraState.yaw) > threshold ||
                    Math.abs(currentState.pitch - lastCameraState.pitch) > threshold ||
                    Math.abs(currentState.distance - lastCameraState.distance) > threshold ||
                    Math.abs(currentState.target.x - lastCameraState.target.x) > threshold ||
                    Math.abs(currentState.target.y - lastCameraState.target.y) > threshold ||
                    Math.abs(currentState.target.z - lastCameraState.target.z) > threshold;
                
                if (changed) {
                    updateCameraInURL();
                }
            }
            
            lastCameraState = currentState;
        }
        
        // Start tracking camera changes after module is initialized
        function startCameraTracking() {
            if (Module && isInitialized) {
                // Poll camera state periodically
                setInterval(trackCameraChanges, 100); // Check every 100ms
            } else {
                setTimeout(startCameraTracking, 100);
            }
        }
        
        // Warn user before leaving page with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges && originalCode !== null) {
                // Standard way to show browser warning
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. If you leave, your changes will be lost.';
                return e.returnValue;
            }
        });
        
        loadLibraryManifest().then(() => {
            console.log('‚úÖ Library manifest loaded');
            manifestLoaded = true;
            checkAndAutoLoad();
        });
        initModule();
        
        // Set up canvas resize handler immediately (before module loads)
        // This ensures initial sizing is correct
        setupCanvasResize();
        
        // Force an immediate resize on page load
        setTimeout(() => {
            resizeCanvas();
        }, 0);
        
        // Start camera tracking after a delay to ensure module is ready
        setTimeout(startCameraTracking, 1000);
    </script>
</body>
</html>

